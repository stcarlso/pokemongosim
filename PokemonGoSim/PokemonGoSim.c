#include "stdafx.h"
#include "battle.h"
#include "pokemon.h"

// The maximum number of movesets available for a mon (could have fewer)
#define MAX_TOTAL_MOVES (MAX_SPECIAL_MOVES * MAX_BASIC_MOVES)
// Gets the name of a move
#define MOVE_NAME(_species, _type, _value) (moves[(_species)->_type[(_value)]].name)

static void dumpStats(RepeatBattleResult *result) {
	// Percentage won
	int n = result->ntimes, pctWin = (100 * result->atkWins + (n >> 1)) / n;
	printf("-- Battled %d times between:\n", n);
	printPokemon(result->attacking);
	puts("-- and");
	printPokemon(result->defending);
	printf("\n-- Attacker won %d/%d (%d%%)\n", result->atkWins, n, pctWin);
	printf("   Average damage done by attacker: %.1f / %d\n", result->avgDefDamage,
		getHP(result->defending) * DEF_HP_MULT);
	printf("   Average damage done by defender: %.1f / %d\n", result->avgAtkDamage,
		getHP(result->attacking) * ATK_HP_MULT);
	printf("   Average time on battle clock   : %.1f s\n\n", result->avgTimeLeft * 0.001);
}

// Creates a 10/10/10 level 20 (41 by our standards) pokemon of the given name
static void createL20Poke(Pokemon *mon, const char *name, const char *basic,
		const char *special) {
	mon->species = getSpeciesName(name);
	mon->level = 41;
	mon->ivAttack = 10;
	mon->ivDefense = 10;
	mon->ivHP = 10;
	mon->basicMove = getMoveName(basic);
	mon->powerMove = getMoveName(special);
}

// Fills in all possible defenders (movesets) in the defenders array
static void generateAllDefenders() {
	Pokemon *mon = &defenders[0];
	int bm, sm;
	for (int i = 0; i < NUM_SPECIES; i++)
		for (int j = 0; j < MAX_TOTAL_MOVES; j++) {
			// Set up species, level 20, 10/10/10
			Species *spec = &specData[i];
			bm = spec->basic[j / MAX_SPECIAL_MOVES];
			sm = spec->special[j % MAX_SPECIAL_MOVES];
			// Do not generate invalid defenders
			if (bm > 0 && sm > 0) {
				mon->species = i;
				mon->level = 41;
				mon->ivAttack = 10;
				mon->ivDefense = 10;
				mon->ivHP = 10;
				// Pick the moves
				mon->basicMove = bm;
				mon->powerMove = sm;
				mon++;
			}
		}
}

// Fills in all possible movesets for one defender at the specified location in the defenders
// array
static void generateOneDefender(const char *name, int offset) {
	int bm, sm, species = getSpeciesName(name);
	Species *spec = &specData[species];
	Pokemon *mon = &defenders[offset];
	for (int j = 0; j < MAX_TOTAL_MOVES; j++) {
		// Set up species, level 20, 10/10/10
		bm = spec->basic[j / MAX_SPECIAL_MOVES];
		sm = spec->special[j % MAX_SPECIAL_MOVES];
		// Do not generate invalid defenders
		if (bm > 0 && sm > 0) {
			mon->species = species;
			mon->level = 41;
			mon->ivAttack = 10;
			mon->ivDefense = 10;
			mon->ivHP = 10;
			// Pick the moves
			mon->basicMove = bm;
			mon->powerMove = sm;
			mon++;
		}
	}
}

// Total number of entries of each type generated by the two methods below
#define TOTAL_ELITE_DEFENDERS 111
#define TOTAL_ELITE_ATTACKERS 114

// Generates all movesets for the top "19" defenders in http://imgur.com/a/tnxxq
static void generateEliteDefenders() {
	generateOneDefender("Lapras", 0);
	generateOneDefender("Snorlax", 6);
	generateOneDefender("Dragonite", 12);
	generateOneDefender("Exeggutor", 18);
	// only one basic moveset
	generateOneDefender("Vaporeon", 24);
	generateOneDefender("Poliwrath", 27);
	generateOneDefender("Wigglytuff", 33);
	generateOneDefender("Slowbro", 39);
	generateOneDefender("Arcanine", 45);
	generateOneDefender("Venusaur", 51);
	generateOneDefender("Vileplume", 57);
	generateOneDefender("Clefable", 63);
	generateOneDefender("Muk", 69);
	generateOneDefender("Victreebel", 75);
	generateOneDefender("Rhydon", 81);
	generateOneDefender("Nidoqueen", 87);
	// Not sure what #17 is?
	generateOneDefender("Hypno", 93);
	generateOneDefender("Charizard", 99);
	generateOneDefender("Dewgong", 105);
}

// Generates all movesets for the top 20 attackers in http://imgur.com/a/tnxxq
static void generateEliteAttackers() {
	generateOneDefender("Snorlax", 200);
	generateOneDefender("Dragonite", 206);
	generateOneDefender("Lapras", 212);
	// only one basic moveset
	generateOneDefender("Vaporeon", 218);
	generateOneDefender("Arcanine", 221);
	generateOneDefender("Exeggutor", 227);
	generateOneDefender("Slowbro", 233);
	generateOneDefender("Blastoise", 239);
	// only one basic moveset
	generateOneDefender("Gyarados", 245);
	generateOneDefender("Muk", 248);
	generateOneDefender("Venusaur", 254);
	generateOneDefender("Nidoqueen", 260);
	generateOneDefender("Charizard", 266);
	generateOneDefender("Wigglytuff", 272);
	generateOneDefender("Poliwrath", 278);
	generateOneDefender("Golduck", 284);
	generateOneDefender("Clefable", 290);
	generateOneDefender("Nidoking", 296);
	generateOneDefender("Rhydon", 302);
	generateOneDefender("Dewgong", 308);
}

// Prompts the user for the base pokemon to use (finds first entry in defenders with name
// matching this one, or -1 if none were found)
static int getBasePokemon() {
	char name[80];
	int base = -1, species, len;
	// Get the mon name to try from stdin
	printf("Defender name: ");
	fflush(stdout);
	fgets(name, 79, stdin);
	len = strlen(name);
	// Strip the newline
	if (len > 0) {
		name[len - 1] = '\0';
		// Retrieve species
		species = getSpeciesName(name);
		if (species >= 0) {
			// Found it
#ifdef _DEBUG
			printf("Matched species: %s (index %d)\n", specData[species].name, species);
#endif
			for (int i = 0; i < MAX_DEFENDERS && base < 0; i++)
				if (defenders[i].species == species)
					base = i;
#ifdef _DEBUG
			printf("Defender index: %d\n", base);
#endif
		}
	}
	return base;
}

// Outputs the battle results (expecting 36) in a matrix
static void printMatrix(RepeatBattleResult *result) {
	Species *atkSpec = &specData[result->attacking->species], *defSpec = &specData[
		result->defending->species];
	// Generate the matrix
	puts("\nKEY:");
	for (int i = 0; i < MAX_TOTAL_MOVES; i++) {
		int fast = i / MAX_SPECIAL_MOVES, charge = i % MAX_SPECIAL_MOVES;
		// Legend to moves
		printf("%1d%1d = %s / %s,  %s / %s\n", fast, charge, MOVE_NAME(atkSpec, basic, fast),
			MOVE_NAME(atkSpec, special, charge), MOVE_NAME(defSpec, basic, fast),
			MOVE_NAME(defSpec, special, charge));
	}
	puts("\nTOTAL:\nAT 00    01    02    10    11    12    DEFENDER");
	for (int i = 0; i < MAX_TOTAL_MOVES; i++) {
		double rt = 0.0, value;
		printf("%1d%1d ", i / MAX_SPECIAL_MOVES, i % MAX_SPECIAL_MOVES);
		for (int j = 0; j < MAX_TOTAL_MOVES; j++) {
			// Show average attack damage to 1 decimal
			value = result[MAX_TOTAL_MOVES * i + j].avgAtkDamage;
			printf("%5.1f ", value);
			rt += value;
		}
		// Row average
		printf("%5.1f\n", rt / (double)MAX_TOTAL_MOVES);
	}
	// Column averages
	printf("-- ");
	for (int i = 0; i < MAX_TOTAL_MOVES; i++) {
		double ct = 0.0;
		for (int j = 0; j < MAX_TOTAL_MOVES; j++)
			ct += result[MAX_TOTAL_MOVES * j + i].avgAtkDamage;
		// Show average attack damage to 1 decimal
		printf("%5.1f ", ct / (double)MAX_TOTAL_MOVES);
	}
	puts("\n");
}

int main() {
	RepeatBattleResult result[TOTAL_ELITE_ATTACKERS];
	Timeline atkTL, defTL;
	// Read in all data and build timeline objects
	initTimeline(&atkTL);
	initTimeline(&defTL);
	if (readMovesBasic() && readMovesPower() && readSpecies() && atkTL.data != NULL &&
			defTL.data != NULL) {
		// Create top mons
		int base;
		generateEliteDefenders();
		generateEliteAttackers();
		base = getBasePokemon();
		if (base >= 0) {
			// Send elite attackers against the defender
			for (int i = 0; i < MAX_TOTAL_MOVES; i++) {
				const Pokemon *defense = &defenders[i + base];
				double td = 0.0, total = (double)TOTAL_ELITE_ATTACKERS;
				unsigned long long totalWins = 0ULL;
				printf("%s has %s / %s...\n", specData[defense->species].name,
					moves[defense->basicMove].name, moves[defense->powerMove].name);
				// This loop can be parallelized, and does it well!
#ifndef _DEBUG
#pragma loop(hint_parallel(8))
#pragma loop(ivdep)
#endif
				for (int j = 0; j < TOTAL_ELITE_ATTACKERS; j++) {
					// Hit against this moveset
#ifdef _DEBUG
					printf("%24s VS %24s...\r", specData[defenders[200 + j].species].name,
						specData[defense->species].name);
					fflush(stdout);
#endif
					// Change this one to determine dodging strategy
					repeatFight(&result[j], &defenders[200 + j], defense, 50000,
						STRAT_NO_DODGE);
				}
				for (int j = 0; j < TOTAL_ELITE_ATTACKERS; j++) {
					// Summary stats
					td += result[j].avgAtkDamage;
					totalWins += (unsigned long long)result[j].atkWins;
				}
				printf("\nAverage damage done to attacker: %.1f (%.2f%% loss rate)\n",
					td / total, 100.0 * (double)totalWins / (50000.0 * total));
			}
		}
		// Done!
		puts("Press ENTER to exit");
		getchar();
		destroyTimeline(&atkTL);
		destroyTimeline(&defTL);
		destroyAll();
	}
	return 0;
}
